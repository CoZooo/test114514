name: Generate Update Pack

on:
  workflow_dispatch:
    inputs:
      from_ref:
        description: "Optional diff base ref (auto detect if empty)"
        required: false
        default: ""
      platform:
        description: "Update package platform"
        required: true
        type: choice
        options:
          - universal
          - client
          - server
        default: universal
      base:
        description: "Current base version"
        required: true
      base_new:
        description: "New base version"
        required: true
      dlc:
        description: "Current DLC version"
        required: true
      dlc_new:
        description: "New DLC version"
        required: true

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version change
        shell: bash
        run: |
          BASE="${{ inputs.base }}"
          BASE_NEW="${{ inputs.base_new }}"
          DLC="${{ inputs.dlc }}"
          DLC_NEW="${{ inputs.dlc_new }}"
          if [ "$BASE" = "$BASE_NEW" ] && [ "$DLC" = "$DLC_NEW" ]; then
            echo "Invalid input: base/base_new and dlc/dlc_new are both unchanged." >&2
            echo "At least one side must change." >&2
            exit 1
          fi

      - name: Resolve diff base ref
        id: base_ref
        shell: bash
        run: |
          INPUT_FROM_REF="${{ inputs.from_ref }}"
          BASE="${{ inputs.base }}"
          DLC="${{ inputs.dlc }}"

          if [ -n "$INPUT_FROM_REF" ]; then
            if ! git rev-parse --verify --quiet "$INPUT_FROM_REF^{commit}" >/dev/null; then
              echo "Invalid from_ref: $INPUT_FROM_REF" >&2
              exit 1
            fi
            RESOLVED="$INPUT_FROM_REF"
            SOURCE="input"
          else
            TARGET_PAIR="${BASE}+${DLC}"
            RESOLVED=""
            SOURCE=""

            while IFS= read -r tag; do
              [ -z "$tag" ] && continue
              case "$tag" in
                */*)
                  right="${tag#*/}"
                  if [ "$right" = "$TARGET_PAIR" ]; then
                    RESOLVED="$tag"
                    SOURCE="target_pair_hot_update_tag"
                    break
                  fi
                ;;
              esac
            done < <(git for-each-ref --sort=-creatordate --format='%(refname:short)' refs/tags)

            if [ -z "$RESOLVED" ]; then
              while IFS= read -r tag; do
                [ -z "$tag" ] && continue
                case "$tag" in
                  */*)
                    RESOLVED="$tag"
                    SOURCE="latest_hot_update_tag"
                    break
                  ;;
                esac
              done < <(git for-each-ref --sort=-creatordate --format='%(refname:short)' refs/tags)
            fi

            if [ -z "$RESOLVED" ]; then
              RESOLVED="$(git rev-list --max-parents=0 HEAD | tail -n 1)"
              SOURCE="initial_commit"
            fi
          fi

          echo "resolved_from_ref=$RESOLVED" >> "$GITHUB_OUTPUT"
          echo "resolved_from_ref_source=$SOURCE" >> "$GITHUB_OUTPUT"

      - name: Generate update package
        id: generate
        run: |
          mkdir -p out
          result="$(
            python3 .github/tools/generate_update_pack.py \
              --from-ref "${{ steps.base_ref.outputs.resolved_from_ref }}" \
              --to-ref "HEAD" \
              --platform "${{ inputs.platform }}" \
              --base "${{ inputs.base }}" \
              --base-new "${{ inputs.base_new }}" \
              --dlc "${{ inputs.dlc }}" \
              --dlc-new "${{ inputs.dlc_new }}"
          )"
          echo "$result"
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              echo "$line" >> "$GITHUB_OUTPUT"
            fi
          done <<< "$result"

      - name: Show generated info
        run: |
          echo "Diff base ref: ${{ steps.base_ref.outputs.resolved_from_ref }}"
          echo "Diff base source: ${{ steps.base_ref.outputs.resolved_from_ref_source }}"
          echo "Release tag suggestion: ${{ steps.generate.outputs.release_tag }}"
          echo "Asset name: ${{ steps.generate.outputs.asset_name }}"
          echo "Zip path: ${{ steps.generate.outputs.zip_path }}"
          echo "Added files: ${{ steps.generate.outputs.add_count }}"
          echo "Deleted files: ${{ steps.generate.outputs.del_count }}"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: update-package-${{ inputs.platform }}-${{ inputs.base_new }}-${{ inputs.dlc_new }}
          path: |
            ${{ steps.generate.outputs.zip_path }}
            ${{ steps.generate.outputs.summary_path }}
            ${{ steps.generate.outputs.changelog_path }}
            ${{ steps.generate.outputs.release_notes_path }}
            work/**/update.dc

      - name: Publish to GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.generate.outputs.release_tag }}"
          ASSET="${{ steps.generate.outputs.zip_path }}"
          NOTES="${{ steps.generate.outputs.release_notes_path }}"

          if gh release view "$TAG" >/dev/null 2>&1; then
            gh release upload "$TAG" "$ASSET" --clobber
          else
            gh release create "$TAG" "$ASSET" --title "$TAG" --notes-file "$NOTES"
          fi
